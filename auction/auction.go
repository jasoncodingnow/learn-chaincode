package main

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"errors"
	"fmt"
	"io"
	"os"
	"runtime"

	"strconv"

	"encoding/json"

	"bufio"
	"net/http"

	"time"

	"github.com/hyperledger/fabric/core/chaincode/shim"
)

//////////////////////////////////////////////////////////////////////////////////////////////////
// The recType is a mandatory attribute. The original app was written with a single table
// in mind. The only way to know how to process a record was the 70's style 80 column punch card
// which used a record type field. The array below holds a list of valid record types.
// This could be stored on a blockchain table or an application
//////////////////////////////////////////////////////////////////////////////////////////////////
var recType = []string{"ARTINV", "USER", "BID", "AUCREQ", "POSTTRAN", "OPENAUC", "CLAUC", "XFER", "VERIFY"}

//////////////////////////////////////////////////////////////////////////////////////////////////
// The following array holds the list of tables that should be created
// The deploy/init deletes the tables and recreates them every time a deploy is invoked
//////////////////////////////////////////////////////////////////////////////////////////////////
var aucTables = []string{"UserTable", "UserCatTable", "ItemTable", "ItemCatTable", "ItemHistoryTable", "AuctionTable", "AucInitTable", "AucOpenTable", "BidTable", "TransTable"}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// A Map that holds TableNames and the number of Keys
// This information is used to dynamically Create, Update
// Replace , and Query the Ledger
// In this model all attributes in a table are strings
// The chain code does both validation
// A dummy key like 2016 in some cases is used for a query to get all rows
//
//              "UserTable":        1, Key: UserID
//              "ItemTable":        1, Key: ItemID
//              "UserCatTable":     3, Key: "2016", UserType, UserID
//              "ItemCatTable":     3, Key: "2016", ItemSubject, ItemID
//              "AuctionTable":     1, Key: AuctionID
//              "AucInitTable":     2, Key: Year, AuctionID
//              "AucOpenTable":     2, Key: Year, AuctionID
//              "TransTable":       2, Key: AuctionID, ItemID
//              "BidTable":         2, Key: AuctionID, BidNo
//              "ItemHistoryTable": 4, Key: ItemID, Status, AuctionHouseID(if applicable),date-time
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
func GetNumberOfKeys(tname string) int {
	TableMap := map[string]int{
		"UserTable":        1,
		"ItemTable":        1,
		"UserCatTable":     3,
		"ItemCatTable":     3,
		"AuctionTable":     1,
		"AucInitTable":     2,
		"AucOpenTable":     2,
		"TransTable":       2,
		"BidTable":         2,
		"ItemHistoryTable": 4,
	}
	return TableMap[tname]
}

// userObject
type UserObject struct {
	UserID    string
	RecType   string // Type = USER
	Name      string
	UserType  string // Auction House (AH), Bank (BK), Buyer or Seller (TR), Shipper (SH), Appraiser (AP)
	Address   string
	Phone     string
	Email     string
	Bank      string
	AccountNo string
	RoutingNo string
}

///////////////////////////////////////////////////////////////////////////////////////
// This creates a record of the Asset (Inventory)
// Includes Description, title, certificate of authenticity or image whatever..idea is to checkin a image and store it
// in encrypted form
// Example:
// Item { 113869, "Flower Urn on a Patio", "Liz Jardine", "10102007", "Original", "Floral", "Acrylic", "15 x 15 in", "sample_9.png","$600", "My Gallery }
///////////////////////////////////////////////////////////////////////////////////////
type ItemObject struct {
	ItemID         string
	RecType        string
	ItemDesc       string
	ItemDetail     string // Could included details such as who created the Art work if item is a Painting
	ItemDate       string
	ItemType       string
	ItemSubject    string
	ItemMedia      string
	ItemSize       string
	ItemPicFN      string
	ItemImage      []byte // This has to be generated AES encrypted using the file name
	AES_Key        []byte // This is generated by the AES Algorithms
	ItemImageType  string // should be used to regenerate the appropriate image type
	ItemBasePrice  string // Reserve Price at Auction must be greater than this price
	CurrentOwnerID string // This is validated for a user registered record
}

////////////////////////////////////////////////////////////////////////////////
// Has an item entry every time the item changes hands
////////////////////////////////////////////////////////////////////////////////
type ItemLog struct {
	ItemID       string // PRIMARY KEY
	Status       string // SECONDARY KEY - OnAuc, OnSale, NA
	AuctionedBy  string // SECONDARY KEY - Auction House ID if applicable
	RecType      string // ITEMHIS
	ItemDesc     string
	CurrentOwner string
	Date         string // Date when status changed
}

/////////////////////////////////////////////////////////////////////////////
// Register a request for participating in an auction
// Usually posted by a seller who owns a piece of ITEM
// The Auction house will determine when to open the item for Auction
// The Auction House may conduct an appraisal and genuineness of the item
/////////////////////////////////////////////////////////////////////////////
type AuctionRequest struct {
	AuctionID      string
	RecType        string // AUCREQ
	ItemID         string
	AuctionHouseID string // ID of the Auction House managing the auction
	SellerID       string // ID Of Seller - to verified against the Item CurrentOwnerId
	RequestDate    string // Date on which Auction Request was filed
	ReservePrice   string // reserver price > previous purchase price
	BuyItNowPrice  string // 0 (Zero) if not applicable else specify price
	Status         string // INIT, OPEN, CLOSED (To be Updated by Trgger Auction)
	OpenDate       string // Date on which auction will occur (To be Updated by Trigger Auction)
	CloseDate      string // Date and time when Auction will close (To be Updated by Trigger Auction)
}

//////////////////////////////////////////////////////////////
// Invoke Functions based on Function name
// The function name gets resolved to one of the following calls
// during an invoke
//
//////////////////////////////////////////////////////////////
func InvokeFunction(fname string) func(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {
	InvokeFunc := map[string]func(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error){
		"PostUser": PostUser,
		"PostItem": PostItem,
	}
	return InvokeFunc[fname]
}

//////////////////////////////////////////////////////////////
// Query Functions based on Function name
//
//////////////////////////////////////////////////////////////
func QueryFunction(fname string) func(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {
	QueryFunc := map[string]func(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error){
		"GetUser": GetUser,
		"GetItem": GetItem,
	}
	return QueryFunc[fname]
}

// auction chaincode
type SimpleChaincode struct {
}

var gopath string
var ccpath string

func main() {
	runtime.GOMAXPROCS(runtime.NumCPU())
	fmt.Println("Starting Item Auction Application chaincode")
	gopath = os.Getenv("GOPATH")
	ccpath = fmt.Sprintf("%s/src/github.com/jasoncodingnow/learn-chaincode/auction/", gopath)
	// Start the shim -- running the fabric
	err := shim.Start(new(SimpleChaincode))
	if err != nil {
		fmt.Println("Error starting Item Fun Application chaincode: %s", err)
	}
}

// init function
func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {
	fmt.Println("[Trade and Auction Application] Init")
	var err error
	for _, aucTable := range aucTables {
		err = stub.DeleteTable(aucTable)
		if err != nil {
			return nil, fmt.Errorf("Init(), Delete table of %s failed", aucTable)
		}
		err = InitLedger(stub, aucTable)
		if err != nil {
			return nil, fmt.Errorf("Init(): InitLedger of %s  Failed ", aucTable)
		}
	}
	err = stub.PutState("version", []byte(strconv.Itoa(1)))
	if err != nil {
		return nil, err
	}
	fmt.Println("Init() Initialization Complete  : ", args)
	return []byte("Init(): Initialization Complete"), nil
}

// invoke function
func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {
	var err error
	var result []byte

	if ChkReqType(args) == true {
		invokeFunction := InvokeFunction(function)
		if invokeFunction != nil {
			result, err = invokeFunction(stub, function, args)
		}
	} else {
		fmt.Println("Invoke() Invalid recType : ", args, "\n")
		return nil, errors.New("Invoke() : Invalid recType : " + args[0])
	}
	return result, err
}

// Query function
func (t *SimpleChaincode) Query(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {
	var err error
	var result []byte

	fmt.Println("ID Extracted and Type = ", args[0])
	fmt.Println("Args supplied : ", args)

	if len(args) < 1 {
		fmt.Println("Query() : Include at least 1 arguments Key ")
		return nil, errors.New("Query() : Expecting Transation type and Key value for query")
	}

	queryFunction := QueryFunction(function)
	if queryFunction != nil {
		result, err = queryFunction(stub, function, args)
	} else {
		fmt.Println("Query() Invalid function call : ", function)
		return nil, errors.New("Query() : Invalid function call : " + function)
	}
	if err != nil {
		fmt.Println("Query() Object not found : ", args[0])
		return nil, errors.New("Query() : Object not found : " + args[0])
	}
	return result, err
}

// type should in recType
func ChkReqType(args []string) bool {
	for _, rt := range args {
		for _, val := range recType {
			if val == rt {
				return true
			}
		}
	}
	return false
}

//////////////////////////////////////////////////////////////////////////////////////////
// Retrieve Auction applications version Information
// This API is to check whether application has been deployed successfully or not
// example:
// ./peer chaincode query -l golang -n mycc -c '{"Function": "GetVersion", "Args": ["version"]}'
//
//////////////////////////////////////////////////////////////////////////////////////////
func GetVersion(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {
	if len(args) < 1 {
		fmt.Println("GetVersion() : Requires 1 argument 'version'")
		return nil, errors.New("GetVersion() : Requires 1 argument 'version'")
	}
	// Get version from the ledger
	version, err := stub.GetState(args[0])
	if err != nil {
		jsonResp := "{\"Error\":\"Failed to get state for version\"}"
		return nil, errors.New(jsonResp)
	}

	if version == nil {
		jsonResp := "{\"Error\":\" auction application version is invalid\"}"
		return nil, errors.New(jsonResp)
	}

	jsonResp := "{\"version\":\"" + string(version) + "\"}"
	fmt.Printf("Query Response:%s\n", jsonResp)
	return version, nil
}

// Post User
func PostUser(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {
	user, err := CreateUserObject(args[0:])
	if err != nil {
		return nil, err
	}
	userbyte, err := UserToJson(user)
	if err != nil {
		fmt.Println("PostuserObject() : Failed Cannot create object buffer for write : ", args[1])
		return nil, errors.New("PostUser(): Failed Cannot create object buffer for write : " + args[1])
	} else {
		keys := []string{args[0]}
		err = UpdateLedger(stub, "UserTable", keys, userbyte)
		if err != nil {
			fmt.Println("PostUser() : write error while inserting record")
			return nil, err
		}
		keys = []string{"2017", args[3], args[0]}
		err = UpdateLedger(stub, "UserCatTable", keys, userbyte)
		if err != nil {
			fmt.Println("PostUser() : write error while inserting recordinto UserCatTable \n")
			return nil, err
		}
	}
	return userbyte, err
}

func GetUser(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {
	var err error
	databytes, err := QueryFromLedger(stub, "UserTable", args)
	if err != nil {
		fmt.Println("GetUser() : Failed to Query Object ")
		jsonResp := "{\"Error\":\"Failed to get  Object Data for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}
	if databytes == nil {
		fmt.Println("GetUser() : Incomplete Query Object ")
		jsonResp := "{\"Error\":\"Incomplete information about the key for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	fmt.Println("GetUser() : Response : Successfull -")
	return databytes, nil
}

// create user from args
func CreateUserObject(args []string) (UserObject, error) {
	var err error
	var user UserObject

	if len(args) != 10 {
		fmt.Println("CreateUserObject(): Incorrect number of arguments. Expecting 10 ")
		return user, errors.New("CreateUserObject() : Incorrect number of arguments. Expecting 10 ")
	}

	_, err = strconv.Atoi(args[0])
	if err != nil {
		return user, errors.New("CreateUserObject() : User ID should be an integer")
	}
	user = UserObject{args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]}
	fmt.Println("CreateUserObject() : User Object : ", user)
	return user, err
}

// convert UserObject to json
func UserToJson(user UserObject) ([]byte, error) {
	userjson, err := json.Marshal(user)
	if err != nil {
		fmt.Println("UserToJson err:", err)
		return nil, err
	}
	return userjson, nil
}

// PostItem
func PostItem(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {
	itemObject, err := CreateItemObject(args)
	if err != nil {
		fmt.Println("PostItem(): Cannot create item object \n")
		return nil, err
	}

	ownerInfo, err := ValidateMember(stub, itemObject.CurrentOwnerID)
	fmt.Println("Owner information  ", ownerInfo, itemObject.CurrentOwnerID)
	if err != nil {
		fmt.Println("PostItem() : Failed Owner information not found for ", itemObject.CurrentOwnerID)
		return nil, err
	}

	buff, err := ARToJson(itemObject)
	if err != nil {
		fmt.Println("PostItem() : Failed Cannot create object buffer for write : ", args[1])
		return nil, errors.New("PostItem(): Failed Cannot create object buffer for write : " + args[1])
	} else {
		keys := []string{args[0]}
		err = UpdateLedger(stub, "ItemTable", keys, buff)
		if err != nil {
			fmt.Println("PostItemLog() : write error while inserting record\n")
			return nil, err
		}
		// Post Entry into ItemCatTable - i.e. Item Category Table
		// The first key 2016 is a dummy (band aid) key to extract all values
		keys = []string{"2017", args[6], args[0]}
		err = UpdateLedger(stub, "ItemCatTable", keys, buff)
		if err != nil {
			fmt.Println("PostItem() : Write error while inserting record into ItemCatTable \n")
			return buff, err
		}
	}
	secret_key, _ := json.Marshal(itemObject.AES_Key)
	fmt.Println(string(secret_key))
	return secret_key, nil
}

/////////////////////////////////////////////////////////////////////////////////////////
// Query callback representing the query of a chaincode
// Retrieve a Item by Item ID
// ./peer chaincode query -l golang -n mycc -c '{"Function": "GetItem", "Args": ["1000"]}'
/////////////////////////////////////////////////////////////////////////////////////////
func GetItem(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {
	var err error
	itembytes, err := QueryFromLedger(stub, "ItemTable", args)
	if err != nil {
		fmt.Println("GetItem() : Failed to Query Object ")
		jsonResp := "{\"Error\":\"Failed to get  Object Data for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}
	if itembytes == nil {
		fmt.Println("GetItem() : Incomplete Query Object ")
		jsonResp := "{\"Error\":\"Incomplete information about the key for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	fmt.Println("GetItem() : Response : Successfull ")
	itemObj, _ := JSONtoAR(itembytes)
	itemObj.ItemImage = []byte{}
	itembytes, _ = ARToJson(itemObj)

	return itembytes, err
}

func CreateItemObject(args []string) (ItemObject, error) {
	var err error
	var item ItemObject
	if len(args) != 12 {
		fmt.Println("CreateItemObject(): Incorrect number of arguments. Expecting 12 ")
		return item, errors.New("CreateItemObject(): Incorrect number of arguments. Expecting 12 ")
	}

	_, err = strconv.Atoi(args[0])
	if err != nil {
		fmt.Println("CreateItemObject(): ART ID should be an integer create failed! ")
		return item, errors.New("CreateItemObject(): ART ID should be an integer create failed!")
	}

	imagePath := ccpath + args[9]
	if _, err = os.Stat(imagePath); err == nil {
		fmt.Println(imagePath, "  exists!")
	} else {
		fmt.Println("CreateItemObject(): Cannot find or load Picture File = %s :  %s\n", imagePath, err)
		return item, errors.New("CreateItemObject(): ART Picture File not found " + imagePath)
	}

	imageBytes, imageType := imageToByteArray(imagePath)

	// Generate a new key and encrypt the image
	AES_key, _ := GenAESKey()
	AES_enc := Encrypt(AES_key, imageBytes)

	// Append the AES Key, The Encrypted Image Byte Array and the file type
	item = ItemObject{args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], AES_enc, AES_key, imageType, args[10], args[11]}
	fmt.Println("CreateItemObject(): Item Object created: ID# ", item.ItemID, "\n AES Key: ", item.AES_Key)
	return item, nil
}

func ValidateMember(stub shim.ChaincodeStubInterface, owner string) ([]byte, error) {
	args := []string{owner, "USER"}
	databytes, err := QueryFromLedger(stub, "UserTable", args)

	if err != nil {
		fmt.Println("ValidateMember() : Failed - Cannot find valid owner record for ART  ", owner)
		jsonResp := "{\"Error\":\"Failed to get Owner Object Data for " + owner + "\"}"
		return nil, errors.New(jsonResp)
	}

	if databytes == nil {
		fmt.Println("ValidateMember() : Failed - Incomplete owner record for ART  ", owner)
		jsonResp := "{\"Error\":\"Failed - Incomplete information about the owner for " + owner + "\"}"
		return nil, errors.New(jsonResp)
	}

	fmt.Println("ValidateMember() : Validated Item Owner:\n", owner)
	return databytes, nil
}

// PostAuctionRequest owner post auction request
func PostAuctionRequest(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {
	aucReg, err := CreateAuctionRequest(args)
	if err != nil {
		return nil, err
	}

	err = VerifyIfItemIsOnAuction(stub, aucReg.ItemID)
	if err != nil {
		fmt.Println("PostAuctionRequest() : Failed Item is either initiated or opened for Auction ", args[0])
		return nil, err
	}

	aucHouse, err := ValidateMember(stub, aucReg.AuctionHouseID)
	fmt.Println("Auction House information  ", aucHouse, " ID: ", aucReg.AuctionHouseID)
	if err != nil {
		fmt.Println("PostAuctionRequest() : Failed Auction House not Registered in Blockchain ", aucReg.AuctionHouseID)
		return nil, err
	}

	itemObject, err := ValidateItemSubmission(stub, aucReg.ItemID)
	if err != nil {
		fmt.Println("PostAuctionRequest() : Failed Could not Validate Item Object in Blockchain ", aucReg.ItemID)
		return itemObject, err
	}

	buff, err := AucReqtoJSON(aucReg)
	if err != nil {
		fmt.Println("PostAuctionRequest() : Failed Cannot create object buffer for write : ", args[1])
		return nil, errors.New("PostAuctionRequest(): Failed Cannot create object buffer for write : " + args[1])
	} else {
		keys := []string{args[0]}
		err = UpdateLedger(stub, "AuctionTable", keys, buff)
		if err != nil {
			fmt.Println("PostAuctionRequest() : write error while inserting record\n")
			return buff, err
		}

		io, err := JSONtoAR(itemObject)
		_, err = PostItemLog(stub, io, "ReadyForAuc", aucReg.AuctionHouseID)
		if err != nil {
			fmt.Println("PostItemLog() : write error while inserting record\n")
			return buff, err
		}

		keys = []string{"2017", args[0]}
		err = UpdateLedger(stub, "AucInitTable", keys, buff)
		if err != nil {
			fmt.Println("PostAuctionRequest() : write error while inserting record into AucInitTable \n")
			return buff, err
		}
	}
	return buff, err
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// POSTS A LOG ENTRY Every Time the Item is transacted
// Valid Status for ItemLog =  OnAuc, OnSale, NA, INITIAL
// Valid AuctionedBy: This value is set to "DEFAULT" but when it is put on auction Auction House ID is assigned
// PostItemLog IS NOT A PUBLIC API and is invoked every time some event happens in the Item's life
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func PostItemLog(stub shim.ChaincodeStubInterface, item ItemObject, status string, ah string) ([]byte, error) {
	iLog := ItemToItemLog(item)
	iLog.Status = status
	iLog.AuctionedBy = ah

	buff, err := ItemLogtoJSON(iLog)
	if err != nil {
		fmt.Println("PostItemLog() : Failed Cannot create object buffer for write : ", item.ItemID)
		return nil, errors.New("PostItemLog(): Failed Cannot create object buffer for write : " + item.ItemID)
	} else {
		keys := []string{iLog.ItemID, iLog.Status, iLog.AuctionedBy, iLog.Date}
		err = UpdateLedger(stub, "ItemHistoryTable", keys, buff)
		if err != nil {
			fmt.Println("PostItemLog() : write error while inserting record\n")
			return buff, err
		}
	}
	return buff, err
}

func ItemLogtoJSON(iLog ItemLog) ([]byte, error) {
	ajson, err := json.Marshal(iLog)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}
	return ajson, nil
}

func ItemToItemLog(io ItemObject) ItemLog {
	iLog := ItemLog{}
	iLog.ItemID = io.ItemID
	iLog.Status = "INITIAL"
	iLog.AuctionedBy = "DEFAULT"
	iLog.RecType = "ILOG"
	iLog.ItemDesc = io.ItemDesc
	iLog.CurrentOwner = io.CurrentOwnerID
	iLog.Date = time.Now().Format("2006-01-02 15:04:05")

	return iLog
}

// CreateAuctionRequest
func CreateAuctionRequest(args []string) (AuctionRequest, error) {
	var err error
	var aucReg AuctionRequest

	if len(args) != 11 {
		fmt.Println("CreateAuctionRegistrationObject(): Incorrect number of arguments. Expecting 11 ")
		return aucReg, errors.New("CreateAuctionRegistrationObject() : Incorrect number of arguments. Expecting 11 ")
	}

	_, err = strconv.Atoi(args[0])
	if err != nil {
		return aucReg, errors.New("CreateAuctionRequest() : User ID should be an integer")
	}

	aucReg = AuctionRequest{args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10]}
	fmt.Println("CreateAuctionObject() : Auction Registration : ", aucReg)

	return aucReg, nil
}

func VerifyIfItemIsOnAuction(stub shim.ChaincodeStubInterface, itemID string) error {
	rows, err := GetListOfOpenAucs(stub, "AucOpenTable", []string{"2017"})
	if err != nil {
		return fmt.Errorf("VerifyIfItemIsOnAuction() operation failed. Error retrieving values from AucOpenTable: %s", err)
	}
	tlist := make([]AuctionRequest, len(rows))
	err = json.Unmarshal([]byte(rows), &tlist)
	if err != nil {
		fmt.Println("VerifyIfItemIsOnAuction: Unmarshal failed : ", err)
		return fmt.Errorf("VerifyIfItemIsOnAuction: operation failed. Error un-marshaling JSON: %s", err)
	}

	for i := 0; i < len(tlist); i++ {
		ar := tlist[i]
		if ar.ItemID == itemID {
			fmt.Println("VerifyIfItemIsOnAuction() : Item Exists")
			return fmt.Errorf("VerifyIfItemIsOnAuction() operation failed. %s", itemID)
		}
	}

	rows, err = GetListOfInitAucs(stub, "AucInitTable", []string{"2017"})
	if err != nil {
		return fmt.Errorf("VerifyIfItemIsOnAuction() operation failed. Error retrieving values from AucInitTable: %s", err)
	}

	tlist = make([]AuctionRequest, len(rows))
	err = json.Unmarshal([]byte(rows), &tlist)
	if err != nil {
		fmt.Println("VerifyIfItemIsOnAuction() Unmarshal failed : ", err)
		return fmt.Errorf("VerifyIfItemIsOnAuction: operation failed. Error un-marshaling JSON: %s", err)
	}
	for i := 0; i < len(rows); i++ {
		ar := tlist[i]
		if ar.ItemID == itemID {
			return fmt.Errorf("VerifyIfItemIsOnAuction() operation failed.")
		}
	}
	return nil
}

// ValidateItemSubmission
func ValidateItemSubmission(stub shim.ChaincodeStubInterface, artId string) ([]byte, error) {
	args := []string{artId, "ARTINV"}
	databytes, err := QueryFromLedger(stub, "ItemTable", args)
	if err != nil {
		fmt.Println("ValidateItemSubmission() : Failed - Cannot find valid owner record for ART  ", artId)
		jsonResp := "{\"Error\":\"Failed to get Owner Object Data for " + artId + "\"}"
		return nil, errors.New(jsonResp)
	}

	if databytes == nil {
		fmt.Println("ValidateItemSubmission() : Failed - Incomplete owner record for ART  ", artId)
		jsonResp := "{\"Error\":\"Failed - Incomplete information about the owner for " + artId + "\"}"
		return nil, errors.New(jsonResp)
	}

	//fmt.Println("ValidateItemSubmission() : Validated Item Owner:", Avalbytes)
	return databytes, nil
}

func GetListOfOpenAucs(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {
	rows, err := GetList(stub, "AucOpenTable", args)
	if err != nil {
		return nil, fmt.Errorf("GetListOfOpenAucs operation failed. Error marshaling JSON: %s", err)
	}

	nCol := GetNumberOfKeys("AucOpenTable")
	tlist := make([]AuctionRequest, len(rows))
	for i := 0; i < len(rows); i++ {
		data := rows[i].Columns[nCol].GetBytes()
		aq, err := JSONtoAucReq(data)
		if err != nil {
			fmt.Println("GetListOfOpenAucs() Failed : Ummarshall error")
			return nil, fmt.Errorf("GetListOfOpenAucs() operation failed. %s", err)
		}
		tlist[i] = aq
	}
	jsonRows, _ := json.Marshal(tlist)
	return jsonRows, nil
}

func GetListOfInitAucs(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {
	rows, err := GetList(stub, "AucInitTable", args)
	if err != nil {
		return nil, fmt.Errorf("GetListOfInitAucs operation failed. Error marshaling JSON: %s", err)
	}
	nCol := GetNumberOfKeys("AucInitTable")
	tlist := make([]AuctionRequest, len(rows))
	for i := 0; i < len(rows); i++ {
		data := rows[i].Columns[nCol].GetBytes()
		ar, err := JSONtoAucReq(data)
		if err != nil {
			fmt.Println("GetListOfInitAucs() Failed : Ummarshall error")
			return nil, fmt.Errorf("getBillForMonth() operation failed. %s", err)
		}
		tlist[i] = ar
	}
	jsonRows, _ := json.Marshal(tlist)
	return jsonRows, nil
}

func GetList(stub shim.ChaincodeStubInterface, tableName string, args []string) ([]shim.Row, error) {
	var columns []shim.Column

	nKeys := GetNumberOfKeys(tableName)
	if nKeys < 1 {
		fmt.Println("Atleast 1 Key must be provided \n")
		return nil, errors.New("GetList failed. Must include at least key values")
	}
	for i := 0; i < nKeys; i++ {
		col := shim.Column{Value: &shim.Column_String_{String_: args[i]}}
		columns = append(columns, col)
	}

	rowChannel, err := stub.GetRows(tableName, columns)
	if err != nil {
		return nil, fmt.Errorf("GetList operation failed. %s", err)
	}
	var rows []shim.Row
	for {
		select {
		case row, ok := <-rowChannel:
			if !ok {
				rowChannel = nil
			} else {
				rows = append(rows, row)
			}
		}
		if rowChannel == nil {
			break
		}
	}

	fmt.Println("Number of Keys retrieved : ", nKeys)
	fmt.Println("Number of rows retrieved : ", len(rows))
	return rows, nil
}

///////////////////////////////////////////////////////////
// Convert Image to []bytes and viceversa
// Detect Image Filetype
// Image Function to read an image and create a byte array
// Currently only PNG images are supported
///////////////////////////////////////////////////////////
func imageToByteArray(imageFile string) ([]byte, string) {
	file, err := os.Open(imageFile)

	if err != nil {
		fmt.Println("imageToByteArray() : cannot OPEN image file ", err)
		return nil, string("imageToByteArray() : cannot OPEN image file ")
	}

	defer file.Close()

	fileInfo, err := file.Stat()
	var size int64 = fileInfo.Size()
	bytes := make([]byte, size)

	buff := bufio.NewReader(file)
	_, err = buff.Read(bytes)

	if err != nil {
		fmt.Println("imageToByteArray() : cannot READ image file")
		return nil, string("imageToByteArray() : cannot READ image file ")
	}

	fileType := http.DetectContentType(bytes)
	fmt.Println("imageToByteArray() : ", fileType)
	//filetype := GetImageType(bytes)

	return bytes, fileType
}

///////////////////////////////////////////////////////////////////////
// Encryption and Decryption Section
// Images will be Encrypted and stored and the key will be part of the
// certificate that is provided to the Owner
///////////////////////////////////////////////////////////////////////
const (
	AESKeyLength = 32 // AESKeyLength is the default AES key length
	NonceSize    = 24 // NonceSize is the default NonceSize
)

// GetRandomBytes
func GetRandomBytes(len int) ([]byte, error) {
	key := make([]byte, len)
	_, err := rand.Read(key)
	if err != nil {
		return nil, err
	}
	return key, nil
}

////////////////////////////////////////////////////////////
// GenAESKey returns a random AES key of length AESKeyLength
// 3 Functions to support Encryption and Decryption
// GENAESKey() - Generates AES symmetric key
// Encrypt() Encrypts a [] byte
// Decrypt() Decryts a [] byte
////////////////////////////////////////////////////////////
func GenAESKey() ([]byte, error) {
	return GetRandomBytes(AESKeyLength)
}

func PKCS5Pad(src []byte) []byte {
	padding := aes.BlockSize - len(src)%aes.BlockSize
	pad := bytes.Repeat([]byte{byte(padding)}, padding)
	return append(src, pad...)
}

func PKCS5Unpad(src []byte) []byte {
	len := len(src)
	unpad := int(src[len-1])
	return src[:(len - unpad)]
}

func Decrypt(key []byte, ciphertext []byte) []byte {

	// Create the AES cipher
	block, err := aes.NewCipher(key)
	if err != nil {
		panic(err)
	}

	// Before even testing the decryption,
	// if the text is too small, then it is incorrect
	if len(ciphertext) < aes.BlockSize {
		panic("Text is too short")
	}

	// Get the 16 byte IV
	iv := ciphertext[:aes.BlockSize]

	// Remove the IV from the ciphertext
	ciphertext = ciphertext[aes.BlockSize:]

	// Return a decrypted stream
	stream := cipher.NewCFBDecrypter(block, iv)

	// Decrypt bytes from ciphertext
	stream.XORKeyStream(ciphertext, ciphertext)

	return ciphertext
}

func Encrypt(key []byte, ba []byte) []byte {

	// Create the AES cipher
	block, err := aes.NewCipher(key)
	if err != nil {
		panic(err)
	}

	// Empty array of 16 + ba length
	// Include the IV at the beginning
	ciphertext := make([]byte, aes.BlockSize+len(ba))

	// Slice of first 16 bytes
	iv := ciphertext[:aes.BlockSize]

	// Write 16 rand bytes to fill iv
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		panic(err)
	}

	// Return an encrypted stream
	stream := cipher.NewCFBEncrypter(block, iv)

	// Encrypt bytes from ba to ciphertext
	stream.XORKeyStream(ciphertext[aes.BlockSize:], ba)

	return ciphertext
}

// Ledger function

// init ledger
func InitLedger(stub shim.ChaincodeStubInterface, tableName string) error {
	nKeys := GetNumberOfKeys(tableName)
	if nKeys < 1 {
		fmt.Println("At least 1 Key must be provided \n")
		fmt.Println("Auction_Application: Failed creating Table ", tableName)
		return errors.New("Auction_Application: Failed creating Table " + tableName)
	}

	var colDefForTbl []*shim.ColumnDefinition
	for i := 0; i < nKeys; i++ {
		columnDef := shim.ColumnDefinition{Name: "keyName" + strconv.Itoa(i), Type: shim.ColumnDefinition_STRING, Key: true}
		colDefForTbl = append(colDefForTbl, &columnDef)
	}

	colLastDef := shim.ColumnDefinition{Name: "Details", Type: shim.ColumnDefinition_BYTES, Key: false}
	colDefForTbl = append(colDefForTbl, &colLastDef)

	err := stub.CreateTable(tableName, colDefForTbl)
	if err != nil {
		fmt.Println("Auction_Application: Failed creating Table ", tableName)
		return errors.New("Auction_Application: Failed creating Table " + tableName)
	}
	return err
}

func UpdateLedger(stub shim.ChaincodeStubInterface, tableName string, key []string, args []byte) error {
	nKeys := GetNumberOfKeys(tableName)
	if nKeys < 1 {
		fmt.Println("Atleast 1 Key must be provided \n")
	}
	var columns []*shim.Column

	for i := 0; i < nKeys; i++ {
		col := shim.Column{Value: &shim.Column_String_{String_: key[i]}}
		columns = append(columns, &col)
	}
	lastCol := shim.Column{Value: &shim.Column_Bytes{Bytes: []byte(args)}}
	columns = append(columns, &lastCol)

	currRow := shim.Row{columns}
	ok, err := stub.InsertRow(tableName, currRow)
	if err != nil {
		return fmt.Errorf("UpdateLedger: InsertRow into "+tableName+" Table operation failed. %s", err)
	}
	if !ok {
		return errors.New("UpdateLedger: InsertRow into " + tableName + " Table failed. Row with given key " + key[0] + " already exists")
	}

	fmt.Println("UpdateLedger: InsertRow into ", tableName, " Table operation Successful. ")
	return nil
}

// DeleteFromLedger
func DeleteFromLedger(stub shim.ChaincodeStubInterface, tableName string, keys []string) error {
	var columns []shim.Column

	nCol := len(keys)
	if nCol < 1 {
		fmt.Println("Atleast 1 Key must be provided \n")
		return errors.New("DeleteFromLedger failed. Must include at least key values")
	}

	for i := 0; i < nCol; i++ {
		col := shim.Column{Value: &shim.Column_String_{String_: keys[i]}}
		columns = append(columns, col)
	}

	err := stub.DeleteRow(tableName, columns)
	if err != nil {
		return fmt.Errorf("DeleteFromLedger operation failed. %s", err)
	}

	fmt.Println("DeleteFromLedger: DeleteRow from ", tableName, " Table operation Successful. ")
	return nil
}

// ReplaceRowFromLedger
func ReplaceRowFromLedger(stub shim.ChaincodeStubInterface, tableName string, keys []string, data []byte) error {
	nKeys := GetNumberOfKeys(tableName)
	if nKeys < 1 {
		fmt.Println("Atleast 1 Key must be provided \n")
	}

	var columns []*shim.Column
	for i := 0; i < nKeys; i++ {
		col := shim.Column{Value: &shim.Column_String_{String_: keys[i]}}
		columns = append(columns, &col)
	}

	dataCol := shim.Column{Value: &shim.Column_Bytes{Bytes: data}}
	columns = append(columns, &dataCol)

	row := shim.Row{columns}
	ok, err := stub.ReplaceRow(tableName, row)
	if err != nil {
		return fmt.Errorf("ReplaceLedgerEntry: Replace Row into "+tableName+" Table operation failed. %s", err)
	}
	if !ok {
		return errors.New("ReplaceLedgerEntry: Replace Row into " + tableName + " Table failed. Row with given key " + keys[0] + " already exists")
	}

	fmt.Println("ReplaceLedgerEntry: Replace Row in ", tableName, " Table operation Successful. ")
	return nil
}

// QueryFromLedger
func QueryFromLedger(stub shim.ChaincodeStubInterface, tableName string, args []string) ([]byte, error) {
	var columns []shim.Column
	nKeys := GetNumberOfKeys(tableName)
	for i := 0; i < nKeys; i++ {
		col := shim.Column{Value: &shim.Column_String_{String_: args[i]}}
		columns = append(columns, col)
	}
	row, err := stub.GetRow(tableName, columns)
	fmt.Println("Length or number of rows retrieved ", len(row.Columns))

	if len(row.Columns) == 0 {
		jsonResp := "{\"Error\":\"Failed retrieving data " + args[0] + ". \"}"
		fmt.Println("Error retrieving data record for Key = ", args[0], "Error : ", jsonResp)
		return nil, errors.New(jsonResp)
	}
	// 所有的数据, key 之后的都是 RecType
	dataBytes := row.Columns[nKeys].GetBytes()
	err = ProcessQueryResult(stub, dataBytes, args)
	if err != nil {
		fmt.Println("QueryLedger() : Cannot create object  : ", args[1])
		jsonResp := "{\"QueryLedger() Error\":\" Cannot create Object for key " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}
	return dataBytes, nil
}

// ProcessQueryResult: check if correct
func ProcessQueryResult(stub shim.ChaincodeStubInterface, bytes []byte, args []string) error {
	// var dat map[string]interface{}
	// if err := json.Unmarshal(bytes, &dat); err != nil {
	// 	panic(err)
	// }

	// var recType string
	// recType = dat["RecTYpe"].(string)
	// switch recType {
	// case "USER":
	// 	_, err := JsonToUser(bytes)
	// 	if err != nil {
	// 		return err
	// 	}
	// 	return err
	// }
	return nil
}

func JsonToUser(bytes []byte) (UserObject, error) {
	user := UserObject{}
	err := json.Unmarshal(bytes, &user)
	if err != nil {
		fmt.Println("JSONtoUser error: ", err)
		return user, err
	}
	fmt.Println("JSONtoUser created: ", user)
	return user, err
}

func ARToJson(ar ItemObject) ([]byte, error) {
	ajson, err := json.Marshal(ar)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}
	return ajson, nil
}

//////////////////////////////////////////////////////////
// Converts JSON String to an ART Object
//////////////////////////////////////////////////////////
func JSONtoAR(data []byte) (ItemObject, error) {

	ar := ItemObject{}
	err := json.Unmarshal([]byte(data), &ar)
	if err != nil {
		fmt.Println("Unmarshal failed : ", err)
	}

	return ar, err
}

//////////////////////////////////////////////////////////
// Converts an User Object to a JSON String
//////////////////////////////////////////////////////////
func JSONtoAucReq(areq []byte) (AuctionRequest, error) {

	ar := AuctionRequest{}
	err := json.Unmarshal(areq, &ar)
	if err != nil {
		fmt.Println("JSONtoAucReq error: ", err)
		return ar, err
	}
	return ar, err
}

//////////////////////////////////////////////////////////
// Converts an Auction Request to a JSON String
//////////////////////////////////////////////////////////
func AucReqtoJSON(ar AuctionRequest) ([]byte, error) {

	ajson, err := json.Marshal(ar)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}
	return ajson, nil
}
